---
title: "tvvar: Sparse Estimation of Time-Varying VAR Models"
output: rmarkdown::html_vignette
bibliography: REFERENCES.bib
vignette: >
  %\VignetteIndexEntry{tvvar: Sparse Estimation of Time-Varying VAR Models}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Installation

The package can be installed with

```{r, eval=FALSE}
install.packages("tvvar")
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse   = TRUE,
  comment    = "#>",
  cache      = TRUE,                 # <— cache results per chunk
  cache.path = "cache/vig-final/",   # <— keep cache in repo
  warning    = FALSE,
  message    = FALSE
)
if (requireNamespace("tvvar", quietly = TRUE)) {
  library(tvvar)
} else if (requireNamespace("devtools", quietly = TRUE)) {
  devtools::load_all("..")   # load package source from parent dir
} else {
  stop("Package tvvar not available; run from package root.")
}

set.seed(1)
```

Make sure to also install `apg`, the package for `accelerated proximal gradient descent` from https://github.com/jpvert/apg:

```{r, eval=FALSE}
install_github("jpvert/apg", force=TRUE)
```

## Background

This package builds on dynamic factor VAR models with conditional heteroskedastic errors [@gorgi2019dfvar]. The `tvvar` package provides a unified framework for estimating and analyzing time-varying vector autoregressive (TV-VAR) models, with support for both maximum likelihood (ML) and Expectation–Maximization (EM/ECM) estimation procedures.  
It extends traditional VAR and dynamic factor models to allow for smoothly evolving autoregressive structures and conditionally heteroskedastic shocks.

The package includes the following main functions:

- **`tvfit()`** – Estimates unpenalized time-varying VAR or dynamic factor VAR models via ML or EM/ECM.  
- **`tvpenfit()`** – Estimates *penalized* TV-VAR models using L1 or adaptive L1 regularization on the factor loadings.  
- **`tvirf()`** – Computes time-varying impulse response functions (IRFs) from estimated models, with support for Monte Carlo-based uncertainty quantification.  

Each function supports consistent interfaces and class methods such as:
- `plot()` — visualize time-varying parameters, IRFs, or forecasts.  
- `summary()` — display key parameter estimates and diagnostics. 
- `predict()` — generate forecasts from fitted models.

## Data
An example of a simulated dataset with `N` = 2, `r` = `p` = 1, with which can be called by:

```{r data}
data(simdata, package = "tvvar")  
str(simdata$Y[1:5, ])
```

gives a list with the following components: 
- `Y`: a T × N matrix containing the observed time series data.\
- `factors`: a T × r matrix of the latent factor time series.\
- `shocks`: a T × N matrix of the VAR shocks (innovations).

# Estimation
[POSSIBLY REFERRING TO PAPER FOR DETAILS ON THE MODEL AND ESTIMATION APPROACH]

## Standard usage of *tvfit*
[WHAT DOES THIS FUNCTION DO]
The function `tvfit()` lets the user specifies the data as input, given as a T x N matrix. The `tvfit()` function returns a `S3` class object `tvvar` which contains the estimated parameters and scores on fit of the model. The function takes the following arguments:

```{r unpenalized, echo = TRUE, eval = TRUE, cache=TRUE}
fit <- tvfit(
  simdata$Y,                       
  p = 1,                      
  r = 1,                      
  zero.mean = TRUE,           
  factor.structure = matrix(1,2,2),            
  method = c("ML","EM"),    
  control    = list(maxit = 2000, trace = 0),           
  em_control = list(max_iter = 200, tol = 1e-3, trace = TRUE), 
  init = c("default","random","custom"),              
  init_list = NULL                                     
)
```


and then we can make a summary of the fitted model using:

```{r summary, eval=FALSE, echo=TRUE}
summary(fit)
```

[INSERT PLOTTING OF FIT]
[PERHAPS SMALL USER OPTIONS OF PLOTTING FUNCTION]


## User options of *tvfit*
[SMALL EXPL of the options broadly, EM/ML]
### Data
A (T × N) numeric matrix containing the observed time series data.  
Each column corresponds to a variable, and each row to a time observation.  
The function assumes the data are ordered chronologically (oldest to newest).

### Lag order `p`
Integer specifying the **lag order** of the VAR component.  
This determines how many past observations enter the autoregressive structure.

### Number of factors `r`
Integer specifying the **number of latent factors** driving the time variation in coefficients.  
Typically small (e.g., 1–3) relative to the number of observed variables.

### Intercept `zero.mean`
Logical; if `TRUE`, the intercept is fixed at zero and the data should be demeaned beforehand.  
If `FALSE`, an intercept is estimated in the constant block `Φ_c`.

### Factor loadings structure `factor.structure` [Needs updating]
Specifies which elements of `Φ_f` (the factor loadings) are free or fixed to zero.  
Can be provided as:
- a 3D array `[N, N, r]`,  
- a list of `r` `N × N` matrices, or  
- a block matrix of size `N × (N * r)`.  
Entries set to zero are treated as fixed.

### Optimization method `method`
Character; either `"ML"` for maximum likelihood estimation (using numerical optimization) or `"EM"` for the expectation–maximization algorithm.  
Both methods estimate the same parameters, but `EM` can be more stable for latent-factor models.

### Control settings for ML `control`
List of optimizer settings for `"ML"` estimation, e.g. `list(maxit = 2000, trace = 0)`. These are passed directly to `optim()`.

### Control settings for EM `em_control`
List of settings for `"EM"` estimation, e.g.  
`list(max_iter = 200, tol = 1e-3, trace = TRUE)`.  
Controls the maximum number of EM iterations, tolerance, and verbosity.

### Initialization type `init`
Initialization mode for the parameter vector.  
Accepts `"default"`, `"random"`, or `"custom"`:
- `"default"` — deterministic starting values based on simple OLS or heuristics.  
- `"random"` — random but stationary initialization (useful for robustness checks).  
- `"custom"` — user-specified starting values via `init_list`.

### Initialization values `init_list`
Optional named list supplying custom starting values.  
The user can override any subset of:
`A`, `B`, `phi_r`, `Omega`, `Phi_c`, or `Phi_f`.  
Entries not provided are filled with defaults.  
Note that `Phi_f` should include only the free entries (those set to 1 in `factor.structure`).



## Standard usage of *tvpenfit*
[INTRO TO WHY PENALISATION IS SOMETIMES NEEDED]
In many macro applications, only a few VAR coefficients truly vary over time. We demonstrate how penalization improves fit and structure recovery when the true factor-loadings block \( \Phi_f \) is sparse. Using the `simsparse` dataset generated by `tvsim()`, we can run the penalized estimation as follows:

```{r penalized, echo=TRUE, eval=TRUE, cache = TRUE}
data(simsparse, package = "tvvar")
sparse_fit <- tvpenfit(simsparse$Y, p = 2, r = 2, penalty_type = "adaptive", init = "default")
```

## User options of *tvpenfit*
Performs penalized estimation of a time-varying VAR (TV-VAR) model using the ECM algorithm with proximal gradient descent. The function introduces an L1 (LASSO-type) penalty on the factor loadings to encourage sparsity. It supports both regular Lasso and adaptive Lasso.

### Data
A (T × N) numeric matrix containing the observed time series data.  
Each column corresponds to a variable, and each row to a time observation.  
Data are assumed to be ordered chronologically.

### Lag order `p`
Integer specifying the lag order of the VAR model, i.e., how many past lags are included.  
Typical values are small (e.g., 1 or 2) for parsimonious models.

### Number of factors `r`
Integer specifying the number of latent factors capturing time variation in the VAR parameters.  
Usually much smaller than the number of observed variables `N`.

### Intercept `zero.mean`
Logical; if `TRUE`, intercepts are fixed at zero, assuming that the data are demeaned.  
If `FALSE`, intercepts are estimated in the constant block `Φ_c`.

### Penalty level `lambda_penalty`
Numeric scalar specifying the strength of the L1 penalty on the factor loadings `Φ_f`.  
Larger values increase shrinkage, leading to sparser solutions.

### Penalty type `penalty_type`
Character; determines the type of penalty used:
- `"regular"` – regular LASSO
- `"adaptive"` – adaptive LASSO, where weights are data-driven and allow less biased estimation of large coefficients.

### Factor loadings structure `factor.structure` [Needs updating]
Optional argument defining which elements of the factor loading matrices `Φ_f` are free or constrained to zero.  
Can be provided as:
- a 3D array `[N, N, r]`,  
- a list of `r` `N × N` matrices, or  
- a block matrix of size `N × (N × r)`.  
Zero entries are treated as fixed, nonzero entries are estimated.

### Initialization type `init`
Specifies how parameter initialization is handled.  
Options:
- `"default"` — heuristic or deterministic starting values,  
- `"random"` — randomized stationary initialization,  
- `"custom"` — user-provided initial values via `init_list`.

### Initialization values `init_list`
Optional named list of user-supplied starting values, required when `init = "custom"`.  
Must include some or all of:  
`A`, `B`, `phi_r`, `Omega`, `Phi_c`, `Phi_f`.  
Any components not provided are filled using defaults.


# Impulse response functions
Impulse response functions (IRFs) show how each variable in the VAR responds over time to a one-unit “shock” in (one of) the variables. For time-varying VARs, IRFs are computed at specific time indices using the filtered states and the time-varying coefficients, so the shape and size of responses can change across the sample.
[More info on IRF]

## Standard usage of *tvirf()*
To compute IRFs from the estimated model `fit`, that has class `tvfit`:

```{r irf, echo=TRUE, eval=TRUE, cache=TRUE}
irf <- tvirf(fit, shock_position = c(1,1), B = 3)
```

Note that if you shock one variable (e.g. `shock_position` = c(1,0,0,...)), the plot shows N panels: each series’ response to that single shock. On the other hand, if you shock multiple variables (e.g. `shock_position` = c(1,1,0,...)), the plot arranges N rows × S columns (S = number of shocked variables): rows are the responding series, columns are the shocked series.

The impulse responses can be plotted by
```{r, echo = TRUE, eval = TRUE, fig.width=8, fig.height=6, fig.align='center'}
plot(irf)
```

By default, the plot shows impulse responses evaluated at the first time point (i.e., the start of the sample).
Since the model is time-varying, impulse responses evolve over time — the transmission of a shock may differ between early and late periods. You can use the argument t in plot() to visualize the responses at other time indices.
For example, to inspect the IRFs corresponding to the third time index `plot(irf, t = 3)`. For models estimated via `tvpenfit()`, the IRFs can still be computed and plotted in the same way. However, uncertainty bounds (confidence intervals) are not reported, as the asymptotic theory for penalized estimators is not yet established. Only median response paths are shown.

```{r, echo = TRUE, eval = TRUE, cache = TRUE, fig.width=8, fig.height=6, fig.align='center'}
irfpen <- tvirf(sparse_fit)
plot(irfpen)
```

## User options of *tvirf()*
The function `tvirf()` computes time-varying impulse response functions (IRFs) based on an estimated model from either `tvfit()` or `tvpenfit()`.  
It simulates how each variable in the system responds to structural shocks over time, accounting for the evolution of model parameters.

Unlike standard VAR models, where IRFs are constant, `tvirf()` produces a sequence of IRFs across time, reflecting how dynamic relationships change throughout the sample. This is useful for analyzing how the transmission of shocks evolves during different economic or financial regimes.

The function supports both unpenalized (ML/EM) and penalized ECM estimates and can handle single or multiple shocks.  
Users can control the IRF horizon, number of Monte Carlo replications, and which time indices are evaluated.

### Fit
Model object returned by `tvfit()` or `tvpenfit()`.  

### Lags
Integer specifying the IRF horizon (default: 10). The x-axis of the resulting plot runs from 0 to lags − 1, corresponding to the number of response periods after a shock.

### T.max
Compute IRFs at the first T.max time indices (use plot(..., t = ·) to pick which to show).

### Monte Carlo draws `B`
Number of Monte Carlo simulations for uncertainty quantification (default: 500).  
- For unpenalized fits, parameters are drawn from the estimated asymptotic covariance, so the bands reflect both parameter and state uncertainty.  
- For penalized fits, parameters are fixed at their penalized estimates; only factor uncertainty is propagated.

### Shock position
Specifies which variable(s) are shocked.  
The preferred format is a length-`N` vector of 0s and 1s (or numeric weights). For example:
- `shock_position = c(1, 0, 0)` shocks only the first variable.  
- `shock_position = c(0, 1, 0)` shocks only the second variable.  
- `shock_position = c(1, 1, 0)` triggers computation of two separate IRFs — one where the first variable is shocked, and another where the second variable is shocked. Each shock generates a distinct IRF object, and all are returned as a bundled list.  

When a list of IRFs (multiple shocks) is passed to plot(), the function automatically arranges the plots in a matrix layout. For instance, in a 3-variable system with shock_position = c(1, 1, 0), `plot(irf)` will produce a 3 × 2 grid of responses.


# Prediction

## Standard usage of *predict()*
After estimating a model with `tvfit()` or `tvpenfit()`, you can use the fitted object to generate forecasts of future observations. The function `predict`()` simulates predictive distributions by combining the estimated time-varying parameters with Monte Carlo draws of future shocks. For example, using the unpenalized fit from earlier:

```{r, echo=TRUE, eval=TRUE, cache=TRUE}
prediction <- predict(fit)
```

This produces a tvpred object containing the forecast paths, their medians, and uncertainty intervals. You can visualize the forecasts with:

```{r, echo = TRUE, eval=TRUE, fig.width=8, fig.height=6, fig.align='center'}
plot(prediction)
```

By default, the plot shows each series over time, with the historical sample on the left and the forecast horizon on the right.
Shaded areas indicate prediction intervals.

## User options of *predict()*

### h
Number of steps ahead to forecast (default 8). Larger h extends the horizon on the right-hand side.

### B
Number of Monte Carlo paths (default 500). Higher B gives smoother quantiles but increases computation time.

### seed
Optional integer seed for reproducibility (default NULL).

### point
Specifies the type of point forecast to report.
Options are mean or median. This affects only the central forecast line, not the prediction intervals.

### use_param_draws
Logical (default TRUE). If TRUE, draws parameters from the asymptotic covariance (uncertainty in both parameters and factors). If FALSE, uses plug-in parameters (only factor/shock uncertainty). Note: for penalized models (tvpenfit), parameter draws are disabled automatically since no asymptotic covariance is available.

### Output
The function returns an object of class tvpred, containing:
- point: forecast means or medians (N × h matrix)
- lb68, ub68: 68% prediction interval bounds
- lb95, ub95: 95% prediction interval bounds
- meta: metadata list including dimensions, h, B, estimation method, and forecast type


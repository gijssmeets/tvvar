---
title: "tvvar: Sparse Estimation of Time-Varying VAR Models"
output: rmarkdown::html_vignette
bibliography: REFERENCES.bib
vignette: >
  %\VignetteIndexEntry{tvvar: Sparse Estimation of Time-Varying VAR Models}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Installation

The package can be installed with

```{r, eval=FALSE}
install.packages("tvvar")
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse   = TRUE,
  comment    = "#>",
  cache      = TRUE,                 # <— cache results per chunk
  cache.path = "cache/vig-final/",   # <— keep cache in repo
  warning    = FALSE,
  message    = FALSE
)
if (requireNamespace("tvvar", quietly = TRUE)) {
  library(tvvar)
} else if (requireNamespace("devtools", quietly = TRUE)) {
  devtools::load_all("..")   # load package source from parent dir
} else {
  stop("Package tvvar not available; run from package root.")
}

set.seed(1)
```

Make sure to also install `apg`, the package for `accelerated proximal gradient descent` from https://github.com/jpvert/apg:

```{r, eval=FALSE}
install_github("jpvert/apg", force=TRUE)
```

## Background

This package builds on dynamic factor VAR models with conditional heteroskedastic errors [@gorgi2019dfvar]. 

[TODO]: Elaborate and refer to own paper


## Data
An example of a simulated dataset with `N` = 2, `r` = `p` = 1, with which can be called by:

```{r data}
data(simdata, package = "tvvar")  
str(simdata$Y[1:5, ])
```

gives a list with the following components: 
- `Y`: a T × N matrix containing the observed time series data.\
- `factors`: a T × r matrix of the latent factor time series.\
- `shocks`: a T × N matrix of the VAR shocks (innovations).

# Estimation
[POSSIBLY REFERRING TO PAPER FOR DETAILS ON THE MODEL AND ESTIMATION APPROACH]

## Standard usage of *tvfit*
[WHAT DOES THIS FUNCTION DO]
The function `tvfit()` lets the user specifies the data as input, given as a T x N matrix. The `tvfit()` function returns a `S3` class object `tvvar` which contains the estimated parameters and scores on fit of the model. The function takes the following arguments:

```{r unpenalized, echo = TRUE, eval = TRUE, cache=TRUE}
fit <- tvfit(
  simdata$Y,                       
  p = 1,                      
  r = 1,                      
  zero.mean = TRUE,           
  phi_f_structure = matrix(1,2,2),            
  method = c("ML","EM"),    
  control    = list(maxit = 2000, trace = 0),           
  em_control = list(max_iter = 200, tol = 1e-3, trace = TRUE), 
  init = c("default","random","custom"),              
  init_list = NULL                                     
)
```


and then we can make a summary of the fitted model using:

```{r summary, eval=FALSE, echo=TRUE}
summary(fit)
```

[INSERT PLOTTING OF FIT]
[PERHAPS SMALL USER OPTIONS OF PLOTTING FUNCTION]


## User options of *tvfit*
[SMALL EXPL of the options broadly, EM/ML]
### Data
A **T × N** numeric matrix containing the observed time series data.  
Each column corresponds to a variable, and each row to a time observation.  
The function assumes the data are ordered chronologically (oldest to newest).

### Lag order `p`
Integer specifying the **lag order** of the VAR component.  
This determines how many past observations enter the autoregressive structure.

### Number of factors `r`
Integer specifying the **number of latent factors** driving the time variation in coefficients.  
Typically small (e.g., 1–3) relative to the number of observed variables.

### Intercept `zero.mean`
Logical; if `TRUE`, the intercept is fixed at zero and the data should be **demeaned** beforehand.  
If `FALSE`, an intercept is estimated in the constant block `Φ_c`.

### Factor loadings structure `phi_f_structure` 
Specifies which elements of `Φ_f` (the factor loadings) are free or fixed to zero.  
Can be provided as:
- a 3D array `[N, N, r]`,  
- a list of `r` `N × N` matrices, or  
- a block matrix of size `N × (N * r)`.  
Entries set to zero are treated as fixed.

### Optimization method `method`
Character; either `"ML"` for **maximum likelihood estimation**  
(using numerical optimization) or `"EM"` for the **expectation–maximization algorithm**.  
Both methods estimate the same parameters, but `EM` can be more stable for latent-factor models.

### Control settings for ML `control`
List of optimizer settings for `"ML"` estimation, e.g.  
`list(maxit = 2000, trace = 0)`.  
These are passed directly to `optim()`.

### Control settings for EM `em_control`
List of settings for `"EM"` estimation, e.g.  
`list(max_iter = 200, tol = 1e-3, trace = TRUE)`.  
Controls the maximum number of EM iterations, tolerance, and verbosity.

### Initialization type `init`
Initialization mode for the parameter vector.  
Accepts `"default"`, `"random"`, or `"custom"`:
- `"default"` — deterministic starting values based on simple OLS or heuristics.  
- `"random"` — random but stationary initialization (useful for robustness checks).  
- `"custom"` — user-specified starting values via `init_list`.

### Initialization values `init_list`
Optional **named list** supplying custom starting values.  
The user can override any subset of:
`A`, `B`, `phi_r`, `Omega`, `Phi_c`, or `Phi_f`.  
Entries not provided are filled with defaults.  
Note that `Phi_f` should include only the **free entries** (those set to 1 in `phi_f_structure`).



## Standard usage of *tvpenfit*
[INTRO TO WHY PEN IS SOMETIMES NEEDED]
[GOOD EXPLANATION TO PHI F STRUCT?]
In many macro applications, only a few VAR coefficients truly vary over time. We demonstrate how penalization improves fit and structure recovery when the true factor-loadings block \( \Phi_f \) is **sparse**. Using the `simsparse` dataset generated by `tvsim()`, we can run the penalized estimation as follows:

```{r penalized, echo=TRUE, eval=FALSE}
data(simsparse, package = "tvvar")
sparse_fit <- tvpenfit(simsparse$Y, p = 2, r = 2, penalty_type = "adaptive", init = "default")
```

## User options of *tvpenfit*
[USER OPTIONS OF PEN]

[SUMMARY]

[PLOT OF FIT]


# Impulse response functions
Impulse response functions (IRFs) show how each variable in the VAR responds over time to a one-unit “shock” in (one of) the variables. For time-varying VARs, IRFs are computed at specific time indices using the filtered states and the time-varying coefficients, so the shape and size of responses can change across the sample.


## Standard usage of *tvirf*
To compute IRFs from the estimated model `fit`, that has class `tvfit`:

```{r irf, echo=TRUE, eval=TRUE, cache=TRUE}
irf <- tvirf(fit, shock_position = c(1,1), B = 3)
```

Note that if you shock one variable (e.g. `shock_position` = c(1,0,0,...)), the plot shows N panels: each series’ response to that single shock. On the other hand, if you shock multiple variables (e.g. `shock_position` = c(1,1,0,...)), the plot arranges N rows × S columns (S = number of shocked variables): rows are the responding series, columns are the shocked series.

The impulse responses can be plotted by
```{r, echo = TRUE, eval = TRUE, fig.width=8, fig.height=6, fig.align='center'}
plot(irf)
```

Tip: Use the t argument in plot() to inspect IRFs at later time indices (e.g., `plot(irf, t = 3)`).



[PERHAPS SMALL USER OPTIONS OF PLOTTING FUNCTION]


[now for irf penalized: note that bounds are not calculated due to missing theory on penalized bounds.]

```{r, echo = TRUE, eval = FALSE}
irfpen <- tvirf(sparse_fit)
plot(irfpen)
```


## User options of *tvirf*
[INTRO ON USER OPTIONS]

### Fit
Model returned by your estimation function.

### Lags
IRF horizon (x-axis runs from 0 to lags − 1).

### T.max
Compute IRFs at the first T.max time indices (use plot(..., t = ·) to pick which to show).

### Monte Carlo draws `B`
- Unpenalized fits: draws parameters from the asymptotic covariance (bands reflect parameter + factor uncertainty).
- Penalized fits: keeps parameters fixed; simulates factor paths only (bands exclude parameter uncertainty).

### Shock position
Preferred way to specify shocks; a length-N vector of 0/1 (or weights). Note that multiple nonzeros compute and return one IRF object per shocked variable (internally bundled).

# Prediction

## Standard usage of *tvpred*
We can also use the fitted model to make predictions. Using the unpenalized fit from earlier, we can predict the next `h` time points as follows:

```{r, echo=TRUE, eval=TRUE, cache=TRUE}
pred <- tvpred(fit)
```

and we can plot it

```{r, echo = TRUE, eval=TRUE, fig.width=8, fig.height=6, fig.align='center'}
plot(pred)
```


## User options of *tvpred*

### h
Number of steps ahead to forecast (default 8). Larger h extends the horizon on the right-hand side.

### B
Number of Monte Carlo paths (default 500). Higher B gives smoother quantiles but increases computation time.

### seed
Optional integer seed for reproducibility (default NULL).

### intervals
Vector of probabilities used for summary bands (default c(0.16, 0.50, 0.84)). The middle value is used as the “center” (median if 0.50 is included), the min/max define the band.

### use_param_draws
Logical (default TRUE).
If TRUE, draws parameters from the asymptotic covariance (uncertainty in both parameters and factors).
If FALSE, uses plug-in parameters (only factor/shock uncertainty).